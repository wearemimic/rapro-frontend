
# Roth Conversion Optimizer - Monte Carlo Sampling Design Spec
## Author: Dr. Elena Vargas

---

## üèóÔ∏è Purpose

Define the stochastic engine that efficiently explores Roth conversion schedules across large solution spaces to feed into the optimizer scoring system.

---

## üîß Key Parameters To Sample

| Variable | Description | Range |
|----------|-------------|-------|
| Start Year | When conversions begin | Current year to retirement year (or slightly beyond retirement age) |
| Conversion Duration | Number of years to convert | 1 to 15 years |
| Annual Conversion Amount | How much is converted per year | $20,000/year up to total qualified balances available |

---

## üîß Monte Carlo Sampling Approach

### 1Ô∏è‚É£ Parameter Sampling

Use numpy-based random samplers for each parameter:

```python
import numpy as np

# Sampling Examples
start_years = np.random.randint(current_year, retirement_year+5, size=num_samples)
durations = np.random.randint(1, 16, size=num_samples)
conversion_amounts = np.random.uniform(20000, max_conversion_limit, size=num_samples)
```

- `num_samples`: typically 10,000 to 100,000 samples per optimization run.
- `max_conversion_limit`: dynamically calculated based on total eligible balances at optimizer start.

---

### 2Ô∏è‚É£ Sampling Rules

- Reject invalid candidates where:
  - Total scheduled conversion exceeds available balances.
  - Total income generated by conversion exceeds hard-coded maximum safe MAGI ceiling (soft ceiling of ~$1M/year MAGI in phase 1).
  - Conversion years overlap beyond simulation end.

- Use pre-filtering logic to remove clearly non-optimal schedules early.

---

### 3Ô∏è‚É£ Sampling Engine

- Use numpy vectorized arrays for fast candidate generation.
- Store candidate schedules as dataframe:

```python
import pandas as pd

candidates = pd.DataFrame({
  'start_year': start_years,
  'duration': durations,
  'annual_conversion': conversion_amounts
})
```

- Clean dataset through filtering logic.

---

### 4Ô∏è‚É£ Parallel Execution

- After candidate generation, dispatch all candidate schedules into the full engine simulation (STEP 1-7) using:

```python
from multiprocessing import Pool

with Pool(cpu_cores) as pool:
    simulation_results = pool.map(run_full_engine, candidate_schedule_list)
```

- Optimize batch processing for high concurrency.

---

### 5Ô∏è‚É£ Optional: Smarter Sampling (Phase 2 Enhancements)

- Implement weighted sampling:
  - Bias toward lower IRMAA tiers (more likely advisor targets).
  - Bias toward earlier conversions if pre-retirement.
  - Allow "tight grid" around most promising zones after initial random sweep.

- Allow initial fast scan, followed by focused local grid search ("zoom in" search).

---

## üîß Developer Notes

- Use numpy, pandas, numba for maximum speed.
- Avoid iterative Python loops ‚Äî fully vectorized sampling.
- Keep initial engine pass simple and purely random ‚Äî focus on volume and filtering for v1.

---

## üõë Critical Business Rules During Sampling

- Balance depletion prevention logic active during schedule generation and filtering.
- IRMAA tier mapping still applies during scoring.
- Taxable income, MAGI, federal tax, AMT, IRMAA penalties fully recalculated inside STEP 1-7 per candidate.

---

## ‚úÖ End of Monte Carlo Sampling Design Spec
